# E8-T7 — Implementar Histórico de Gerações

## Objetivo
Implementar página de histórico mostrando gerações anteriores de documentos. Usuários poderão ver, filtrar e regenerar documentos já criados.

## Dependências
- `E8-T3` (Implementar Upload de Documentos - para ter fluxo de geração completo)

## Entregáveis
**Legenda de status:** `[x]` Concluído · `[~]` Parcial · `[ ]` Pendente

### Backend
- [ ] `GET /api/generate/history` — Listar histórico de gerações
- [ ] Paginação (limit, offset)
- [ ] Filtros: data, template, status
- [ ] Ordenação: mais recentes primeiro

### Frontend
- [ ] Página `/app/generation/history`
- [ ] Tabela com gerações anteriores
- [ ] Colunas: Documento, Template, Data, Status, Ações
- [ ] Botão "Regenerar" para cada geração
- [ ] Filtros por data, template, status
- [ ] Busca por documento
- [ ] Paginação

## Especificação do Endpoint Backend

### GET /api/generate/history

**Query Parameters:**
```
limit: number (default: 10, max: 100)
offset: number (default: 0)
template: string (opcional, filtrar por template)
status: string (opcional, valores: completed, failed, pending)
start_date: ISO 8601 (opcional, gera depois desta data)
end_date: ISO 8601 (opcional, gera antes desta data)
search: string (opcional, buscar no título do documento)
```

**Response (200 OK):**
```json
{
  "data": [
    {
      "id": "uuid",
      "document_id": "uuid",
      "document_title": "Meu Documento",
      "template_id": "uuid",
      "template_name": "Relatório Executivo",
      "status": "completed",
      "created_at": "2025-11-10T10:30:00Z",
      "generated_content_preview": "Lorem ipsum dolor sit amet...",
      "word_count": 1250,
      "processing_time_seconds": 45,
      "model_used": "deepseek"
    },
    // ... mais itens
  ],
  "pagination": {
    "total": 150,
    "limit": 10,
    "offset": 0,
    "pages": 15
  }
}
```

**Validações:**
- limit máx 100 (prevenir abuso)
- offset >= 0
- Filtros opcionais

**Error Responses:**
```json
{
  "error": "Invalid date format"
}
```

---

## Implementação Frontend

### 1. GenerationHistoryPageComponent

**Arquivo a criar:**
```
src/app/features/generation/
├── pages/
│   └── generation-history-page.component.ts    [NOVO]
│       ├── generation-history-page.component.html
│       └── generation-history-page.component.scss
├── components/
│   ├── generation-history-table/               [NOVO]
│   │   ├── generation-history-table.component.ts
│   │   ├── generation-history-table.component.html
│   │   └── generation-history-table.component.scss
│   ├── generation-history-filters/             [NOVO]
│   │   ├── generation-history-filters.component.ts
│   │   ├── generation-history-filters.component.html
│   │   └── generation-history-filters.component.scss
│   └── generation-history-preview-modal/       [NOVO]
│       ├── generation-history-preview-modal.component.ts
│       ├── generation-history-preview-modal.component.html
│       └── generation-history-preview-modal.component.scss
└── services/
    └── generation.service.ts                   [ESTENDER]
```

### 2. GenerationService — Adicionar Métodos

**Métodos a adicionar:**
```typescript
getGenerationHistory(
  limit?: number,
  offset?: number,
  filters?: HistoryFilter
): Observable<HistoryResponse>

regenerateDocument(
  generationId: string,
  templateId?: string
): Observable<GenerateResponse>
```

**Tipos:**
```typescript
interface HistoryFilter {
  template?: string;
  status?: 'completed' | 'failed' | 'pending';
  startDate?: string;
  endDate?: string;
  search?: string;
}

interface GenerationHistoryItem {
  id: string;
  document_id: string;
  document_title: string;
  template_id: string;
  template_name: string;
  status: 'completed' | 'failed' | 'pending';
  created_at: string;
  generated_content_preview: string;
  word_count: number;
  processing_time_seconds: number;
  model_used: string;
}

interface HistoryResponse {
  data: GenerationHistoryItem[];
  pagination: {
    total: number;
    limit: number;
    offset: number;
    pages: number;
  };
}
```

### 3. GenerationHistoryPageComponent

**Template HTML:**
```html
<div class="generation-history-container">
  <div class="header">
    <h2>Histórico de Gerações</h2>
    <p class="subtitle">Veja e regenere documentos já criados</p>
  </div>

  <!-- Filtros -->
  <app-generation-history-filters
    [templates]="templates"
    (filterChange)="onFilterChange($event)">
  </app-generation-history-filters>

  <!-- Tabela -->
  <app-generation-history-table
    [items]="historyItems"
    [isLoading]="isLoading"
    [total]="total"
    [pageSize]="pageSize"
    [currentPage]="currentPage"
    (pageChange)="onPageChange($event)"
    (preview)="onPreview($event)"
    (regenerate)="onRegenerate($event)">
  </app-generation-history-table>

  <!-- Preview Modal -->
  <app-generation-history-preview-modal
    *ngIf="selectedItem"
    [item]="selectedItem"
    (close)="selectedItem = null">
  </app-generation-history-preview-modal>
</div>
```

**Código TypeScript:**
```typescript
@Component({
  selector: 'app-generation-history-page',
  templateUrl: './generation-history-page.component.html',
  styleUrls: ['./generation-history-page.component.scss']
})
export class GenerationHistoryPageComponent implements OnInit {
  historyItems: GenerationHistoryItem[] = [];
  templates: Template[] = [];
  isLoading = false;
  total = 0;
  pageSize = 10;
  currentPage = 0;
  selectedItem: GenerationHistoryItem | null = null;

  private filters: HistoryFilter = {};

  constructor(
    private generationService: GenerationService,
    private snackBar: MatSnackBar,
    private dialog: MatDialog
  ) {}

  ngOnInit() {
    this.loadTemplates();
    this.loadHistory();
  }

  private loadTemplates() {
    this.generationService.getTemplates()
      .subscribe({
        next: (templates) => {
          this.templates = templates;
        },
        error: (error) => {
          console.error('Erro ao carregar templates:', error);
        }
      });
  }

  private loadHistory() {
    this.isLoading = true;
    const offset = this.currentPage * this.pageSize;

    this.generationService.getGenerationHistory(this.pageSize, offset, this.filters)
      .subscribe({
        next: (response) => {
          this.historyItems = response.data;
          this.total = response.pagination.total;
          this.isLoading = false;
        },
        error: (error) => {
          this.showError('Erro ao carregar histórico');
          this.isLoading = false;
        }
      });
  }

  onFilterChange(filters: HistoryFilter) {
    this.filters = filters;
    this.currentPage = 0; // Reset para primeira página
    this.loadHistory();
  }

  onPageChange(page: number) {
    this.currentPage = page;
    this.loadHistory();
  }

  onPreview(item: GenerationHistoryItem) {
    this.selectedItem = item;
  }

  onRegenerate(item: GenerationHistoryItem) {
    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      width: '400px',
      data: {
        title: 'Regenerar Documento?',
        message: `Deseja regenerar "${item.document_title}" usando o template "${item.template_name}"?`,
        confirmText: 'Regenerar',
        cancelText: 'Cancelar'
      }
    });

    dialogRef.afterClosed().subscribe(result => {
      if (result) {
        this.regenerate(item.id);
      }
    });
  }

  private regenerate(generationId: string) {
    this.generationService.regenerateDocument(generationId)
      .subscribe({
        next: (response) => {
          this.showSuccess('Regeneração iniciada');
          // Navegar para página de progresso?
          // this.router.navigate(['/app/generation/progress', response.task_id]);
        },
        error: (error) => {
          this.showError('Erro ao iniciar regeneração');
        }
      });
  }

  private showSuccess(message: string) {
    this.snackBar.open(message, 'Fechar', { duration: 3000 });
  }

  private showError(message: string) {
    this.snackBar.open(message, 'Fechar', { duration: 5000, panelClass: ['error'] });
  }
}
```

### 4. GenerationHistoryFiltersComponent

**O que Implementar:**
- [ ] Campo de busca por documento
- [ ] Select de template
- [ ] Select de status
- [ ] Range de datas (data início, data fim)
- [ ] Botão "Limpar Filtros"
- [ ] Emitir evento ao mudar filtro

**Template:**
```html
<mat-card class="filters-card">
  <mat-card-content>
    <div class="filter-row">
      <!-- Busca -->
      <mat-form-field class="filter-field">
        <mat-label>Buscar Documento</mat-label>
        <input
          matInput
          [formControl]="searchControl"
          placeholder="Nome do documento...">
      </mat-form-field>

      <!-- Template -->
      <mat-form-field class="filter-field">
        <mat-label>Template</mat-label>
        <mat-select [formControl]="templateControl">
          <mat-option value="">Todos</mat-option>
          <mat-option *ngFor="let t of templates" [value]="t.id">
            {{ t.name }}
          </mat-option>
        </mat-select>
      </mat-form-field>

      <!-- Status -->
      <mat-form-field class="filter-field">
        <mat-label>Status</mat-label>
        <mat-select [formControl]="statusControl">
          <mat-option value="">Todos</mat-option>
          <mat-option value="completed">Concluído</mat-option>
          <mat-option value="pending">Em Progresso</mat-option>
          <mat-option value="failed">Falha</mat-option>
        </mat-select>
      </mat-form-field>

      <!-- Data Início -->
      <mat-form-field class="filter-field">
        <mat-label>Data Início</mat-label>
        <input
          matInput
          type="date"
          [formControl]="startDateControl">
      </mat-form-field>

      <!-- Data Fim -->
      <mat-form-field class="filter-field">
        <mat-label>Data Fim</mat-label>
        <input
          matInput
          type="date"
          [formControl]="endDateControl">
      </mat-form-field>

      <!-- Botão Limpar -->
      <button
        mat-stroked-button
        (click)="clearFilters()">
        Limpar Filtros
      </button>
    </div>
  </mat-card-content>
</mat-card>
```

### 5. GenerationHistoryTableComponent

**O que Implementar:**
- [ ] Tabela Material com dados
- [ ] Colunas: Documento, Template, Data, Status, Palavras, Tempo, Ações
- [ ] Status badge (verde=completed, vermelho=failed, amarelo=pending)
- [ ] Ações: Visualizar (eye icon), Regenerar (refresh icon)
- [ ] Paginação (Material Paginator)
- [ ] Loader enquanto busca

### 6. GenerationHistoryPreviewModalComponent

**O que Implementar:**
- [ ] Modal mostrando preview do conteúdo gerado
- [ ] Primeiras 500 caracteres do conteúdo
- [ ] Botões: Copiar, Baixar, Regenerar, Fechar
- [ ] Informações: Template, Data, Tempo processamento, Modelo

## Rota no Aplicativo

**Adicionar ao routing:**
```typescript
{
  path: 'app',
  component: AppLayoutComponent,
  children: [
    // ... outras rotas
    {
      path: 'generation/history',
      component: GenerationHistoryPageComponent
    }
  ]
}
```

## Orientações de Implementação

1. **Paginação**
   - Usar Material Paginator
   - Carregar nova página ao mudar
   - Manter estado de filtros

2. **Filtros**
   - Atualizar ao mudar cada filtro
   - Reset para primeira página ao filtrar
   - Considerar debounce em busca (wait 300ms)

3. **Status Badge**
   - Verde: completed
   - Vermelho: failed
   - Amarelo: pending

4. **Performance**
   - Limitar preview a 500 caracteres
   - Lazy load de conteúdo completo

## Padrões de Código Obrigatórios
- Usar Reactive Forms
- OnDestroy para unsubscribe
- Material Design para componentes
- Error handling robusto
- Documentar com JSDoc

## Testes Obrigatórios
**Legenda de status:** `[x]` Concluído · `[~]` Parcial · `[ ]` Pendente

### Backend
- [ ] Teste: GET /api/generate/history retorna lista
- [ ] Teste: Paginação funciona (limit, offset)
- [ ] Teste: Filtro por template funciona
- [ ] Teste: Filtro por status funciona
- [ ] Teste: Filtro por data funciona
- [ ] Teste: Busca por documento funciona
- [ ] Teste: Ordenação (mais recentes primeiro)

### Frontend
- [ ] Teste: Página carrega histórico
- [ ] Teste: Filtros atualizam lista
- [ ] Teste: Paginação funciona
- [ ] Teste: Preview modal abre
- [ ] Teste: Botão regenerar funciona
- [ ] Teste: Busca tem debounce

## Estimativa
**Responsável:** Backend Team (1-2 dias) + Frontend Team (2-3 dias)
**Deadline:** 26 de Novembro
**Estimativa:** 2-3 dias total
**Status:** ⏳ Não Iniciado

## Links Relacionados
- [agents_vector_dev.md](../frontend/agents_vector_dev.md)
- [Status_Implementação.md](../frontend/status/Status_Implementação.md)
